{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * A client library for the w3name - IPNS over HTTP API. It provides a\n * convenient interface for creating names, making revisions to name records,\n * and publishing and resolving them via the HTTP API.\n *\n * @example\n * ```js\n * import * as Name from 'w3name'\n *\n * const name = await Name.create()\n *\n * console.log('Name:', name.toString())\n * // e.g. k51qzi5uqu5di9agapykyjh3tqrf7i14a7fjq46oo0f6dxiimj62knq13059lt\n *\n * // The value to publish\n * const value = '/ipfs/bafkreiem4twkqzsq2aj4shbycd4yvoj2cx72vezicletlhi7dijjciqpui'\n * const revision = await Name.v0(name, value)\n *\n * // Publish the revision\n * await Name.publish(revision, name.key)\n *\n * // Resolve the latest value\n * await Name.resolve(name)\n * ```\n * @module\n */\n\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { keys, PrivateKey, PublicKey } from 'libp2p-crypto'\nimport { identity } from 'multiformats/hashes/identity'\nimport { base36 } from 'multiformats/bases/base36'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as ipns from 'ipns'\nimport * as cbor from 'cborg'\nimport W3NameService from './service'\nimport fetch from '@web-std/fetch'\n\nconst libp2pKeyCode = 0x72\nconst ONE_YEAR = 1000 * 60 * 60 * 24 * 365\n\nconst defaultValidity = (): string => new Date(Date.now() + ONE_YEAR).toISOString()\n\nconst defaultService = new W3NameService()\n/**\n * Name is an IPNS key ID.\n *\n * Names can be used to retrieve the latest published value from the W3name service\n * using the {@link resolve} function.\n *\n * Note that `Name` contains only the public verification key and does not allow publishing\n * or updating records. To create or update a record, use the {@link WritableName} subclass.\n *\n * To convert from a string representation of a name to a `Name` object use the {@link parse} function.\n */\nexport class Name {\n  /** @internal */\n  _pubKey: PublicKey\n\n  constructor (pubKey: PublicKey) {\n    /**\n     * @private\n     */\n    this._pubKey = pubKey\n  }\n\n  /**\n   * A binary representation of the IPNS verification key.\n   */\n  get bytes (): Uint8Array {\n    const digest = Digest.create(identity.code, this._pubKey.bytes)\n    return CID.createV1(libp2pKeyCode, digest).bytes\n  }\n\n  /**\n   * @returns the string representation of the IPNS verification key (e.g. `k51qzi5uqu5di9agapykyjh3tqrf7i14a7fjq46oo0f6dxiimj62knq13059lt`)\n   */\n  toString (): string {\n    const digest = Digest.create(identity.code, this._pubKey.bytes)\n    return CID.createV1(libp2pKeyCode, digest).toString(base36)\n  }\n}\n\n/**\n * WritableName is a {@link Name} that has a signing key associated with it such that\n * new IPNS record {@link Revision}s can be created and signed for it.\n *\n * New `WritableName`s can be generated using the {@link create} function.\n *\n * To load a `WritableName` from a saved binary representation, see {@link from}.\n */\nexport class WritableName extends Name {\n  /** @internal */\n  _privKey: PrivateKey\n\n  constructor (privKey: PrivateKey) {\n    super(privKey.public)\n    /**\n     * @private\n     */\n    this._privKey = privKey\n  }\n\n  /**\n   * The private signing key, as a libp2p `PrivateKey` object.\n   *\n   * To save a key for later loading with {@link from}, write the\n   * contents of `key.bytes` somewhere safe.\n   */\n  get key (): PrivateKey {\n    return this._privKey\n  }\n}\n\n/**\n * Create a new name with associated signing key that can be used to create and\n * publish IPNS record revisions.\n */\nexport async function create (): Promise<WritableName> {\n  const privKey = await keys.generateKeyPair('Ed25519', 2048)\n  return new WritableName(privKey)\n}\n\n/**\n * Parses a string-encoded {@link Name} to a {@link Name} object.\n *\n * Note that this returns a read-only {@link Name}, which can be used to {@link resolve} values\n * but cannot {@link publish} them.\n */\nexport function parse (name: string): Name {\n  const keyCid = CID.parse(name, base36)\n  if (keyCid.code !== libp2pKeyCode) {\n    throw new Error(`Invalid key, expected ${libp2pKeyCode} codec code but got ${keyCid.code}`)\n  }\n  const pubKey = keys.unmarshalPublicKey(Digest.decode(keyCid.multihash.bytes).bytes)\n  return new Name(pubKey)\n}\n\n/**\n * Creates a {@link WritableName} from an existing signing key (private key).\n *\n * Expects the given `Uint8Array` to contain a binary representation of a\n * private signing key. Note that this is **not** the same as the output of\n * {@link Name#bytes | Name.bytes}, which always returns an encoding of the _public_ key,\n * even when the name in question is a {@link WritableName}.\n *\n * To save the key for a {@link WritableName} so that it can be used with this\n * function, use `key.bytes`, for example:\n *\n * @example\n * ```js\n * import * as Name from 'w3name'\n * import fs from 'fs'\n *\n * async function example() {\n *   const myName = await Name.create()\n *\n *   // myName.key.bytes can now be written to disk / database, etc.\n *   await fs.promises.writeFile('myName.key', myName.key.bytes)\n *\n *   // let's pretend some time has passed and we want to load the\n *   // key from disk:\n *   const loadedBytes = await fs.promises.readFile('myName.key')\n *   const myName2 = await Name.from(loadedBytes)\n *\n *   // myName and myName2 can now be used interchangeably\n * }\n * ```\n *\n */\nexport async function from (key: Uint8Array): Promise<WritableName> {\n  const privKey = await keys.unmarshalPrivateKey(key)\n  return new WritableName(privKey)\n}\n\n/**\n * Create an initial version of the IPNS record for the passed {@link Name}, set to the\n * passed value.\n *\n * Note that the returned {@link Revision} object must be {@link publish}ed before it\n * can be {@link resolve}d using the service.\n */\nexport async function v0 (name: Name, value: string): Promise<Revision> {\n  return new Revision(name, value, 0n, defaultValidity())\n}\n\n/**\n * Create a {@link Revision} of the passed IPNS record by incrementing the sequence\n * number and changing the value.\n *\n * This returns a new {@link Revision} and  does not alter the original `revision` argument.\n */\nexport async function increment (revision: Revision, value: string): Promise<Revision> {\n  const seqno = revision.sequence + 1n\n  return new Revision(revision.name, value, seqno, defaultValidity())\n}\n\n/**\n * A representation of a IPNS record that may be initial or revised.\n */\nexport class Revision {\n  /** @internal */\n  _name: Name\n\n  /** @internal */\n  _value: string\n\n  /** @internal */\n  _sequence: bigint\n\n  /** @internal */\n  _validity: string\n\n  constructor (name: Name, value: string, sequence: bigint, validity: string) {\n    this._name = name\n    if (typeof value !== 'string') {\n      throw new Error('invalid value')\n    }\n    this._value = value\n    if (typeof sequence !== 'bigint') {\n      throw new Error('invalid sequence number')\n    }\n    this._sequence = sequence\n    if (typeof validity !== 'string') {\n      throw new Error('invalid validity')\n    }\n    // TODO: validate format\n    this._validity = validity\n  }\n\n  get name (): Name {\n    return this._name\n  }\n\n  get value (): string {\n    return this._value\n  }\n\n  get sequence (): bigint {\n    return this._sequence\n  }\n\n  /**\n   * RFC3339 date string.\n   */\n  get validity (): string {\n    return this._validity\n  }\n\n  /**\n   * Encodes a `Revision` to a binary representation and returns it as a `Uint8Array`.\n   *\n   * Note: if `revision.name` is a `WritableName` then signing key data will be\n   * lost. i.e. the private key is not encoded.\n   */\n  static encode (revision: Revision): Uint8Array {\n    return cbor.encode({\n      name: revision._name.toString(),\n      value: revision._value,\n      sequence: revision._sequence,\n      validity: revision._validity\n    })\n  }\n\n  /**\n   * Decodes a `Revision` from a binary representation.\n   *\n   * @param bytes - a `Uint8Array` containing a binary encoding of a `Revision`, as produced by {@link #encode}.\n   * @returns a {@link Revision} object\n   * @throws if `bytes` does not contain a valid encoded `Revision`\n   */\n  static decode (bytes: Uint8Array): Revision {\n    const raw = cbor.decode(bytes)\n    const name = parse(raw.name)\n    return new Revision(name, raw.value, BigInt(raw.sequence), raw.validity)\n  }\n}\n\n/**\n * Publish a name {@link Revision} to W3name.\n *\n * Names should be {@link resolve}-able immediately via the w3name service, and will be\n * provided to the IPFS DHT network.\n *\n * Note that it may take a few seconds for the record to propagate and become available via\n * the IPFS DHT network and IPFS <-> HTTP gateways.\n */\nexport async function publish (revision: Revision, key: PrivateKey, service: W3NameService = defaultService): Promise<void> {\n  const url = new URL(`name/${revision.name.toString()}`, service.endpoint)\n  const entry = await ipns.create(\n    key,\n    uint8ArrayFromString(revision.value),\n    revision.sequence,\n    new Date(revision.validity).getTime() - Date.now()\n  )\n  await service.waitForRateLimit()\n  await maybeHandleError(fetch(url.toString(), {\n    method: 'POST',\n    body: uint8ArrayToString(ipns.marshal(entry), 'base64pad')\n  }))\n}\n\n/**\n * Resolve the current IPNS record revision for the passed name.\n *\n * Note that this will only resolve names published using the W3name service. Names published by\n * other IPNS implementations should be resolved using a DHT-backed implementation (e.g. kubo, js-ipfs, etc).\n */\nexport async function resolve (name: Name, service: W3NameService = defaultService): Promise<Revision> {\n  const url = new URL(`name/${name.toString()}`, service.endpoint)\n  await service.waitForRateLimit()\n\n  const res: globalThis.Response = await maybeHandleError(fetch(url.toString()))\n  const { record } = await res.json()\n\n  const entry = ipns.unmarshal(uint8ArrayFromString(record, 'base64pad'))\n  const keyCid = CID.decode(name.bytes)\n  const pubKey = keys.unmarshalPublicKey(Digest.decode(keyCid.multihash.bytes).bytes)\n\n  await ipns.validate(pubKey, entry)\n\n  return new Revision(\n    name,\n    uint8ArrayToString(entry.value),\n    entry.sequence,\n    uint8ArrayToString(entry.validity)\n  )\n}\n\nasync function maybeHandleError (resPromise: Promise<globalThis.Response>): Promise<globalThis.Response> {\n  const res = await resPromise\n  if (res.ok) return res\n  let error\n  try {\n    const parsedError = await res.json()\n    error = new Error(parsedError.message)\n  } catch (jsonParseError) {\n    error = new Error(`unexpected response from API, cannot parse error response. Received status: ${res.status}`)\n  }\n  throw error\n}\n"],"names":["defaultValidity","Date","now","toISOString","defaultService","W3NameService","Name","constructor","pubKey","this","_pubKey","bytes","digest","Digest","create","identity","code","CID","createV1","toString","base36","WritableName","privKey","super","public","_privKey","key","parse","name","keyCid","Error","keys","unmarshalPublicKey","decode","multihash","Revision","value","sequence","validity","_name","_value","_sequence","_validity","static","revision","cbor","encode","raw","BigInt","async","maybeHandleError","resPromise","res","ok","error","parsedError","json","message","jsonParseError","status","generateKeyPair","unmarshalPrivateKey","seqno","service","url","URL","endpoint","entry","ipns","uint8ArrayFromString","getTime","waitForRateLimit","fetch","method","body","uint8ArrayToString","marshal","record","unmarshal","fromString","validate"],"mappings":"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"}